# B. データ構造とアルゴリズム

## 概要

適切なデータ構造とアルゴリズムの選択は、プログラムの効率性を大きく左右します。基本的なデータ構造、計算量の概念、代表的なアルゴリズム設計技法を理解しましょう。

---

## 基本データ構造

**配列**は連続したメモリ領域にデータを格納し、インデックスによるO(1)アクセスが可能です。一方、**リスト**（連結リスト）は要素の挿入・削除がO(1)で行えますが、ランダムアクセスにはO(n)かかります。

**スタック**はLIFO（後入れ先出し）、**キュー**はFIFO（先入れ先出し）の特性を持ちます。**ハッシュテーブル**はキーと値のペアを格納し、平均O(1)での検索・挿入・削除が可能です。**木構造**は階層的なデータ表現に適し、二分探索木ではO(log n)での検索が可能です。

---

## 計算量

**Big-O記法**はアルゴリズムの効率を入力サイズnの関数として表現します。時間計算量（処理時間）と空間計算量（メモリ使用量）の両方を考慮することが重要です。

主要な計算量クラス：O(1) 定数時間、O(log n) 対数時間、O(n) 線形時間、O(n log n)、O(n²) 二次時間。入力サイズが大きくなった際の増加傾向を把握し、要件に合った計算量のアルゴリズムを選択します。

---

## 探索とソート

**線形探索**はO(n)、**二分探索**はソート済みデータに対しO(log n)で検索可能です。

ソートアルゴリズムは用途により使い分けます。クイックソートは平均O(n log n)で高速、マージソートは安定ソートで最悪でもO(n log n)を保証、バブルソートはO(n²)で教育目的以外では非推奨です。

---

## アルゴリズム設計技法

**分割統治**は問題を小さな部分問題に分割し、それぞれを解いて統合します（例：マージソート）。**動的計画法**は部分問題の解をメモ化して再計算を避けます（例：フィボナッチ数列）。

**貪欲法**は各ステップで局所的最適解を選びます（例：コイン問題）。**バックトラッキング**は解の候補を探索し、条件を満たさなければ戻って別の候補を試します（例：迷路探索）。

```python
# 動的計画法の例：フィボナッチ数列
def fib(n, memo={}):
    if n in memo: return memo[n]
    if n <= 1: return n
    memo[n] = fib(n-1, memo) + fib(n-2, memo)
    return memo[n]
```

---

## 重要なポイント

1. データ構造は操作の頻度に応じて選択する
2. Big-O記法で計算量を評価する習慣をつける
3. 探索はデータがソート済みかどうかで手法が変わる
4. アルゴリズム設計技法は問題の性質に合わせて適用する
